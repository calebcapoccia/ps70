<!DOCTYPE html>
<html lang="en">

<title>PS70: Intro to Digital Fabrication </title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="../style.css" rel="stylesheet">
<link href="../typewriter.css" rel="stylesheet">


<nav class="navbar navbar-expand-sm navbar-dark" style=" color: #EEE7E8;">
  <div style="align-items: center; justify-content: center;" class="container-fluid">
    <div class="flexrow">
      <h2 class="nav-title">Caleb Capoccia's PS70 Site</h2>
    </div>
    <div class="navbar-nav">
      <h4><a class="nav-link" href="../index.html">Home</a></h4>
      <h4><a class="nav-link" href="../about.html">About</a></h4>
    </div>
  </div>
</nav>

<body>
<xmp style="display:none;">
<div class="textcontainer typewriter-texture">
<p class="margin">   </p>

<h3>Week 4: Microcontroller Programming</h3>

<h4>Introduction</h4>

<p>For this week, I wanted to expand my goalie kinematic sculpture from last week. The main way I planned to do this was to use a potentiometer to control the motor. From lab, I thought that I could use the mapping function to map the potentiometer scale to a full rotation of the motor shaft, as this rotates the small gear by one rotation, which then rotates the larger gear by half a rotation, representing the range of motion from one end of the goal to the other.</p>

<p>After doing some online research and confirming with Kassia, I quickly realized the yellow DC motor has no way of knowing where it's current position is, so would not have a way of mapping the potentiometer to an exact angle without introducing additional hardware.</p>

<p>There were two potential paths I could take: Either use two buttons to control the direction of the yellow DC motor, or I could figure out how to implement a step motor with a potentiometer. For the potentiometer, I would also need to use a button to "reset" the goalie.</p>

<p>Last week, I learned it is prudent to start with something simple, and then you can expand. Thus, I decided to pursue the two button approach, and then if sufficient time, shift to using the step motor.</p>

<h4>Initial Implementation</h4>

<p>I started out with the Arduino code we used for the L9110 H, and then I modified it to keep track of the button presses to determine motor direction.</p>

<pre><code class="prettyprint lang-language-arduino prettyprinted">const int A1A = D0;
const int A1B = D1;

const int leftButtonPin = D7;
const int rightButtonPin = D8;

int leftVal;
int rightVal;

void setup() {
  Serial.begin(9600);
  pinMode(A1A, OUTPUT);
  pinMode(A1B, OUTPUT);
  digitalWrite(A1A, LOW);   // start with the motors off 
  digitalWrite(A1B, LOW);
  pinMode(leftButtonPin, INPUT_PULLUP);
  pinMode(rightButtonPin, INPUT_PULLUP);
}

void loop() {
  // Read button values
  leftVal = digitalRead(leftButtonPin);
  rightVal = digitalRead(rightButtonPin);

  // If both buttons are pressed or if neither is pressed, stop the motor
  if ((leftVal == LOW && rightVal == LOW) || (leftVal == HIGH && rightVal == HIGH)) {
    digitalWrite(A1A, LOW);
    digitalWrite(A1B, LOW);
  }

  // Left button pressed, move counter-clockwise
  else if (leftVal == LOW && rightVal == HIGH) {
    digitalWrite(A1A, HIGH);   
    digitalWrite(A1B, LOW);
  }

  // Right button pressed, move clockwise
  else {
    digitalWrite(A1A, LOW);
    digitalWrite(A1B, HIGH); 
  }
}
</code></pre>

<p>Here's a video of the button control working:</p>

<video src="./IMG_8289.mov" controls style="max-width: 600px;"></video>

<p>One thing I noticed, as you can see in the video, is that when the motor switches directions, it jumps around a bit, so if I proceeded with the button setup I would need to reprint the board to bring the motor housing closer to the gear so that more of the motor is firmly locked in the housing to prevent it from jumping out of place.</p>

<img src="./IMG_8287.jpg" alt="Motor housing issue" style="max-width: 600px;">

<p>I also performed some user testing (thanks Eliza!) to determine if the width of the goalie is sufficient, and it seems like the 10 mm width is still sufficient to block shots, so I decided to not adjust the width for now.</p>

<h4>Extension</h4>

<p>After completing the initial working version of the controllable goalie, I wanted to expand the scope. Given that pursuing the step motor path would entail reprinting the board and motor housing and require using a different power driver for practically the same result (controlling the goalie), I decided it would be much more interesting to extend the project along a different dimension: I would use an sensor to detect when a goal is scored, and then use that detection to activate a buzzer.</p>

<p>Because I was continuing with the DC motor, I reprinted the motor housing sides to be much longer, which would then clamp the motor into place. This was much more material efficient than my initial idea of reprinting the base board.</p>

<img src="./image.png" alt="Reprinted motor housing" style="max-width: 600px;">

<p>For the buzzer, I chose a small SM buzzer, and followed <a href="https://www.instructables.com/How-to-use-a-Buzzer-Arduino-Tutorial/" target="_blank">this Instructables tutorial</a>. For the sensor I chose an HC-SR04 ultrasonic sensor, and followed <a href="https://projecthub.arduino.cc/Isaac100/getting-started-with-the-hc-sr04-ultrasonic-sensor-7cabe1" target="_blank">this Arduino tutorial</a>. However, given that the echo pin of the sensor is 5V, and we are working with a 3.3V microcontroller, I would need to scale down the voltage before returning the signal to the microcontroller, or else I would risk frying it. Victor recommended using a voltage divider setup, so I followed portions of a <a href="https://www.youtube.com/watch?v=SIc6zj06bhQ&t=117s" target="_blank">YouTube tutorial</a> to understand and set up the divider.</p>

<img src="./image1.png" alt="Voltage divider diagram" style="max-width: 600px;">

<p>As we can see in the circuitry and equation above, as long as R_2 = 2 * R_1, we will get the 2/3 ratio needed to scale 5V to 3.3V. Thus, I chose a 20K ohm resistor for R_2 and a 10K ohm resistor for R_1.</p>

<p>This is the circuit diagram I ended up with:</p>

<img src="./IMG_9AE668137C77-1.jpeg" alt="Circuit diagram" style="max-width: 600px;">

<p>This is what that looked like on the board:</p>

<img src="./IMG_8295.jpg" alt="Circuit on board" style="max-width: 600px;">

<p>To affix the sensor to the goal, I cut small holes in the mesh net to slide the sensor through.</p>

<p>Here is what I ended up with for code:</p>

<pre><code class="prettyprint lang-language-arduino prettyprinted">const int A1A = D0;
const int A1B = D1;

const int leftButtonPin = D7;
const int rightButtonPin = D8;
const int buzzerPin = D9;

const int trigPin = D5;
const int echoPin = D6;

int leftVal;
int rightVal;

float duration, distance;

void setup() {
  // Serial.begin(9600);
  pinMode(A1A, OUTPUT);
  pinMode(A1B, OUTPUT);
  pinMode(buzzerPin, OUTPUT);
  digitalWrite(A1A, LOW);   // start with the motors off 
  digitalWrite(A1B, LOW);
  pinMode(leftButtonPin, INPUT_PULLUP);
  pinMode(rightButtonPin, INPUT_PULLUP);
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
}

void loop() {
  // Read button values
  leftVal = digitalRead(leftButtonPin);
  rightVal = digitalRead(rightButtonPin);

  // If both buttons are pressed or if neither is pressed, stop the motor
  if ((leftVal == LOW && rightVal == LOW) || (leftVal == HIGH && rightVal == HIGH)) {
    // Serial.println("Both pressed or neither");
    digitalWrite(A1A, LOW);
    digitalWrite(A1B, LOW);
  }

  // Left button pressed, move counter-clockwise
  else if (leftVal == LOW && rightVal == HIGH) {
    // Serial.println("Left pressed");
    digitalWrite(A1A, HIGH);   
    digitalWrite(A1B, LOW);
  }

  // Right button pressed, move clockwise
  else {
    // Serial.println("Right pressed");
    digitalWrite(A1A, LOW);
    digitalWrite(A1B, HIGH); 
  }

  // Send signal
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(8);
  digitalWrite(trigPin, LOW);

  // Receive signal
  duration = pulseIn(echoPin, HIGH);
  distance = (duration*.0343)/2 * 10; // Get distance in mm
  // If an object is detected in the net
  if (distance < 80 || distance > 1000) {
    // Ring the buzzer
    tone(buzzerPin, 2000);
  }
  else {
    // Turn the buzzer off
    noTone(buzzerPin);
  }

  delay(100);
}
</code></pre>

<p>At baseline, the sensor hits the mesh net on the other side around ~110mm away, so 80mm was a safe bet for under. I had to check for distance > 1000 because when the ball is right next to the sensor it returns very long distances 2k, 10k.</p>

<p>Here's the system in action, which I am calling "Blockautomaton Bobby."</p>

<video src="./IMG_8303.mov" controls style="max-width: 600px;"></video>

<h4>Additional Troubleshooting</h4>

<p>As I was running the contraption, I ran into brown outs a few times, and then when trying to re-upload the code, was running into exit status 2 errors. After troubleshooting with Victor for a couple of hours, we figured out that a reliable way to reset the microcontroller was to hold the boot button, hit the reset button, and then release the boot button. We also moved the D7-D9 pins to D2-D4 and this seemed to fix the issue, so it might be that the microcontroller was using D7-D9 for other purposed under the hood.</p>

<p>Here is the updated code snippet for the pin setup:</p>

<pre><code class="prettyprint lang-language-arduino prettyprinted">const int A1A = D0;
const int A1B = D1;

const int leftButtonPin = D2;
const int rightButtonPin = D3;
const int buzzerPin = D4;

const int trigPin = D5;
const int echoPin = D6;
</code></pre>

<p>Along with the updated circuit diagram:</p>

<img src="./IMG_CC5C8AA39543-1.jpeg" alt="Updated circuit diagram" style="max-width: 600px;">

<p class="margin">   </p>

</div>
</xmp>
</body>

<script src="../strapdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" ></script>

</html>